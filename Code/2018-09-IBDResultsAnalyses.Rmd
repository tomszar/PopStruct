---
title: "Analysis of Refined IBD Results"
output: html_document
---

In this notebook we will analyze the results from the run of IBD. 
Specifically, we will decompose the pairwise similarity matrix using a randomized svd using the whole dataset.
To generate different clusters, we will use a model based-clustering applied to the adapt samples only. 
To interpret those clusters we will use the PCA to visually assess the proximity to known populations.

## Preliminaries

Loading libraries

```{r load libraries}
library(tidyverse)
library(ggpubr)
library(mclust)
library(rsvd)
library(pophelper)
```

Loading databases

```{r databases, warning=FALSE}
#Opening cm matrix
setwd('..')
path <- getwd()
setwd(paste(path, "/Results/RefinedIBD/merge_dense_phenos_geno_maf_hwe_mind01_ref", sep = ""))
cm <- read.csv("cMmatrix.txt", row.names = 1)

#Opening popinfo
setwd(paste(path, "/DataBases/PopInfo", sep = ""))
pops_hgdp <- read_delim("SampleInformation.txt", delim = "\t")[,c(1,3,5)]
colnames(pops_hgdp) <- c("ID", "pop", "super_pop")

pops_100g <- read_delim("integrated_call_samples_v3.20130502.ALL.panel", delim = "\t", col_types = cols(
  X1 = col_character(),
  X2 = col_character(),
  X3 = col_character()
))[,c(1:3)]
colnames(pops_100g)[1] <- c("ID")

#Changing the hgdp id names
for (i in 1:dim(pops_hgdp)[1] ) {
  nint   <- nchar(pops_hgdp[i,1])
  nzeros <- paste(integer(5-nint), collapse="")
  pops_hgdp[i,1] <- paste("HGDP", nzeros, pops_hgdp[i,1], sep = "")
}
pops <- bind_rows(pops_100g, pops_hgdp)

#Changing the HGDP super_pop
pops$super_pop[pops$super_pop == "AFRICA"]      <- "AFR"
pops$super_pop[pops$super_pop == "AMERICA"]     <- "AMR"
pops$super_pop[pops$super_pop == "EAST_ASIA"]   <- "EAS"
pops$super_pop[pops$super_pop == "EUROPE"]      <- "EUR"
pops$super_pop[pops$super_pop == "MIDDLE_EAST"] <- "MDE"
pops$super_pop[pops$super_pop == "OCEANIA"]     <- "OCE"
pops$super_pop[pops$super_pop == "CENTRAL_SOUTH_ASIA"] <- "SAS"

#Changing to factors
#pops <- pops %>% mutate(pop=as.factor(pop), super_pop=as.factor(super_pop))

#Generating final pop file
pops_total <- as_tibble(rownames(cm)) %>% rename(ID = value) %>% left_join(pops, by = "ID") %>%
                mutate(pop = ifelse(is.na(pop), "ADAPT", pop)) %>% 
                mutate(super_pop = ifelse(is.na(super_pop), "ADAPT", super_pop))
   
#Opening PCA from allele sharing
setwd(paste(path, "/Results/PCA", sep = ""))
pca <- read_delim("merge_sparse_phenos_geno_maf_hwe_mind01_ref_pruned_PCA.eigenvec", col_names=FALSE,
                  delim=" ")
pca <- pca %>% select(-X1)
colnames(pca)[1] <- "ID"
colnames(pca)[2:ncol(pca)] <- paste("PC", seq(1:ncol(pca)), sep="")

#Adding pop info pca
pca <- pca %>% left_join(pops_total, by = "ID")

#Read admixture files
setwd(paste(path, "/Results/Admixture", sep = ""))
all_files <- list.files(pattern = ".*dense_phenos.*Q")
admix <- readQ(all_files)
fam <- read_delim("merge_dense_phenos_geno_maf_hwe_mind01_ref_pruned.fam", delim=" ", col_names=FALSE) %>% select(X2)
colnames(fam) <- "ID"
fam <- fam %>% left_join(pops_total, by="ID")

#Read finestructure clusters
setwd(paste(path, "/Results/FineStructure", sep = ""))
fsclust <- read_delim("fs_clust.csv", delim=",", col_names=FALSE )
fsclust <- fsclust %>% mutate(X2 = as.factor(X2))
colnames(fsclust) <- c("ID", paste("k", 2:10, sep=""))

#Add fsgroup var to pops_total
pops_total <- pops_total %>% left_join(fsclust, by ="ID")
```

## Distribution of IBD values

Let's see the distribution of IBD values (in cm) before  its transformation.

```{r distribution}
lower_only <- as.matrix(cm)[lower.tri(cm)]
summary(lower_only[lower_only>0] )
hist(lower_only[lower_only>0] )
```

Compare that to the distribution after applying a data transformation, specifically, getting the square root of the values, and inverting the matrix to a distance matrix.

```{r transforming matrix}
#Getting the sqrt
cm <- sqrt(cm)

#Getting distance matrix
cm <- max(cm, na.rm=T) - cm
diag(cm) <- 0

#Normalizing? (substracting mean matrix value, look at Lawson and Falush 2012)
cm_normal <- cm - mean(as.matrix(cm)[lower.tri(cm)])
diag(cm_normal) <- 0

lower_only <- as.matrix(cm)[lower.tri(cm)]
summary(lower_only[lower_only>0] )
hist(lower_only[lower_only>0] )

#Possible way to get very low values
#b <- which(cm<10 & cm>0, arr.in=TRUE)

#replace diagonal with full identity which was calculated as the sum of cM length of all autosomes , approx 3545.825789
#diag(myMatrix) <- 3546
```

## SVD

We will run a randomized svd (rsvd) on the whole dataset. 

```{r svd}
#Running rsvd on whole dataset
set.seed(100)
sv <- rsvd(cm, 100)
sv_normal <- rsvd(cm_normal, 100)

#Run PA to determine the number of components!!!!!!!
rand_eigenvals <- as.data.frame(matrix(0, 99, 100))
for(i in 1:99){
  shuffled <- apply(cm,2,sample,nu=0,nv=0)
  diag(shuffled) <- 0
  rsv <- rsvd(shuffled, 100)
  rand_eigenvals[i,] <- rsv$d
}

last_component <- as.numeric(which(apply(rand_eigenvals,2, mean) > sv$d)[1])

u  <- sv_normal$u
rownames(u) <- rownames(cm) 
colnames(u) <- paste("PC", seq(1:ncol(u)), sep="")
u <- as_tibble(u, rownames = "ID")
u <- u %>% left_join(pops_total, by = "ID")
```

Let's compare the results from the IBD matrix with a normal PCA from plink

```{r plot_all}
plotoneg <- function(dat, x1, y1){
  p1 <- ggplot(dat, aes_string(x = x1, y = y1, color = "super_pop")) +
            geom_point(alpha = 0.3, size = 2) + labs(color = "pop") +
            theme_pubr()
  p1 <- ggpar(p1, palette = "jco")
  return(p1)
}

p1 <- plotoneg(filter(u, super_pop != "ADAPT"), "PC1", "PC2")
p2 <- plotoneg(filter(u, super_pop != "ADAPT"), "PC3", "PC4")
p3 <- plotoneg(filter(u, super_pop != "ADAPT"), "PC5", "PC6")
p4 <- plotoneg(filter(u, super_pop != "ADAPT"), "PC7", "PC8")
p5 <- plotoneg(filter(u, super_pop != "ADAPT"), "PC9", "PC10")
p6 <- plotoneg(filter(u, super_pop != "ADAPT"), "PC11", "PC12")

ggarrange(p1, p2, p3, p4, p5, p6, 
          nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")

p1 <- plotoneg(filter(pca, super_pop!="ADAPT"), "PC1", "PC2")
p2 <- plotoneg(filter(pca, super_pop!="ADAPT"), "PC3", "PC4")
p3 <- plotoneg(filter(pca, super_pop!="ADAPT"), "PC5", "PC6")
p4 <- plotoneg(filter(pca, super_pop!="ADAPT"), "PC7", "PC8")
p5 <- plotoneg(filter(pca, super_pop!="ADAPT"), "PC9", "PC10")
p6 <- plotoneg(filter(pca, super_pop!="ADAPT"), "PC11", "PC12")

ggarrange(p1, p2, p3, p4, p5, p6, 
          nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```


Looking at within continent variation

```{r EUR}
plotoneg <- function(dat, x1, y1){
  p1 <- ggplot(dat, aes_string(x = x1, y = y1, color = "pop")) +
            geom_point(alpha = 0.3, size = 2) + labs(color = "pop") +
            theme_pubr()
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}

p1 <- plotoneg(filter(u, super_pop == "EUR"), "PC1", "PC2")
p2 <- plotoneg(filter(u, super_pop == "EUR"), "PC3", "PC4")
p3 <- plotoneg(filter(u, super_pop == "EUR"), "PC5", "PC6")
p4 <- plotoneg(filter(u, super_pop == "EUR"), "PC7", "PC8")
p5 <- plotoneg(filter(u, super_pop == "EUR"), "PC9", "PC10")
p6 <- plotoneg(filter(u, super_pop == "EUR"), "PC11", "PC12")

ggarrange(p1, p2, p3, p4, p5, p6, 
          nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")


p1 <- plotoneg(filter(pca, super_pop == "EUR"), "PC1", "PC2")
p2 <- plotoneg(filter(pca, super_pop == "EUR"), "PC3", "PC4")
p3 <- plotoneg(filter(pca, super_pop == "EUR"), "PC5", "PC6")
p4 <- plotoneg(filter(pca, super_pop == "EUR"), "PC7", "PC8")
p5 <- plotoneg(filter(pca, super_pop == "EUR"), "PC9", "PC10")
p6 <- plotoneg(filter(pca, super_pop == "EUR"), "PC11", "PC12")

ggarrange(p1, p2, p3, p4, p5, p6, 
          nrow = 3, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

Running model-based clustering only on adapt samples, using the first 30 components

```{r model}

#Supervised method
reference <- u %>% filter(super_pop != "ADAPT")
superv_model <- MclustDA(reference[2:(last_component+1)], reference$pop)
summary(superv_model)
reference_model <- Mclust(reference[2:25], G=1:30)
table(reference$pop, reference_model$classification)
#Predict with new data
predict_model <- predict.MclustDA(superv_model, filter(u, super_pop == "ADAPT")[2:(last_component+1)])
summary(droplevels(predict_model$classification))

#Run mclust 
set.seed(88)
model_clust <- Mclust(filter(u, super_pop == "ADAPT")[2:(last_component+1)], G=1:20)
summary(model_clust)
```

```{r}
mclust_res <- u %>% filter(super_pop == "ADAPT") %>% select("ID") %>% 
             bind_cols(as.data.frame(model_clust$classification))
colnames(mclust_res)[2] <- "group"
mclust_res <- mclust_res %>% mutate(group = as.factor(group))
u <- u %>% left_join(mclust_res, by="ID")

fam <- fam %>% left_join(mclust_res, by="ID")

```

Cluster 1

```{r}
plot_by_group <- function(dat, x1, y1, cont, clust){
  dat  <- filter(u, super_pop == cont)
  dat2 <- filter(u, group == clust)  
  p1 <- ggplot(dat, aes_string(x = x1, y = y1, color = "pop")) +
            geom_point(alpha = 0.3, size = 2) +
            geom_point(data = dat2, alpha=0.3) +
            theme_pubr()
  p1 <- ggpar(p1, palette = "jama")
  return(p1)
}

p1 <- plot_by_group(u, "PC1", "PC2", "AMR", "1")
p2 <- plot_by_group(u, "PC3", "PC4", "AMR", "1")
ggarrange(p1, p2,
          nrow = 1, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

Cluster 2

```{r}
p1 <- plot_by_group(u, "PC1", "PC2", "EUR", "2")
p2 <- plot_by_group(u, "PC3", "PC4", "EUR", "2")
ggarrange(p1, p2,
          nrow = 1, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

Cluster 3

```{r}
p1 <- plot_by_group(u, "PC1", "PC2", "AFR", "3")
p2 <- plot_by_group(u, "PC3", "PC4", "AFR", "3")
ggarrange(p1, p2,
          nrow = 1, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

Cluster 4

```{r}
p1 <- plot_by_group(u, "PC1", "PC2", "EUR", "4")
p2 <- plot_by_group(u, "PC3", "PC4", "EUR", "4")
ggarrange(p1, p2,
          nrow = 1, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

Cluster 5

```{r}
p1 <- plot_by_group(u, "PC1", "PC2", "AFR", "5")
p2 <- plot_by_group(u, "PC3", "PC4", "AFR", "5")
ggarrange(p1, p2,
          nrow = 1, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

Cluster 6

```{r}
p1 <- plot_by_group(u, "PC1", "PC2", "EAS", "6")
p2 <- plot_by_group(u, "PC3", "PC4", "EAS", "6")
ggarrange(p1, p2,
          nrow = 1, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

Cluster 7

```{r}
p1 <- plot_by_group(u, "PC1", "PC2", "AMR", "7")
p2 <- plot_by_group(u, "PC3", "PC4", "AMR", "7")
ggarrange(p1, p2,
          nrow = 1, ncol = 2,
          common.legend = TRUE, legend = "right", 
          align = "v")
```

## Admixture

```{r}
#Plot reference samples
notadapt <- fam$pop != "ADAPT"
admix_notadapt <- lapply(admix, function(x) x[notadapt,])
group_lab <- fam %>% filter(super_pop!="ADAPT") %>% select(super_pop, pop) %>% 
  mutate(super_pop=as.character(super_pop) , pop=as.character(pop))

p1 <- plotQ(admix_notadapt, returnplot=T, exportplot=F, quiet=T, basesize=11, showsp=F,
            grplab=as.data.frame(group_lab),  grplabangle = 90, ordergrp=T)
plot(p1$plot[[9]])

#Plot adapt samples
adapt <- fam$pop=="ADAPT"
admix_adapt <- lapply(admix, function(x) x[adapt,])
group_lab <- fam %>% filter(super_pop=="ADAPT") %>% select(group) %>% 
  mutate(group=as.character(group))
p2 <- plotQ(admix_adapt, returnplot=T, exportplot=F, quiet=T, basesize=11, showsp=F,
            grplab=as.data.frame(group_lab),  grplabangle = 90, ordergrp=T, sortind = "all")
plot(p2$plot[[9]])
```


```{r}
par(mfrow = c(2,2))
plot(model_clust, what = "uncertainty", dimens = c(1,2), main = "")
plot(model_clust, what = "uncertainty", dimens = c(3,4), main = "")
plot(model_clust, what = "uncertainty", dimens = c(5,6), main = "")
plot(model_clust, what = "uncertainty", dimens = c(7,8), main = "")

```

Export classification components
```{r}
setwd('..')
path <- getwd()
setwd(paste(path, "/Results/Mclust", sep = ""))

write.table(mclust_res, "mclust_class.csv",  sep=",", quote = FALSE, col.names = FALSE, row.names = FALSE)

```

